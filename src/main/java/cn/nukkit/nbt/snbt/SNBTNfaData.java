/* Generated by: JavaCC 21 Parser Generator. SNBTNfaData.java */
package cn.nukkit.nbt.snbt;

import java.util.BitSet;
import java.util.EnumSet;

import static cn.nukkit.nbt.snbt.SNBTConstants.TokenType.*;


/**
 * Holder class for the data used by SNBTLexer
 * to do the NFA thang
 */
class SNBTNfaData implements SNBTConstants {

    // The functional interface that represents
    // the acceptance method of an NFA state
    interface NfaFunction {

        TokenType apply(int ch, BitSet bs, EnumSet<TokenType> validTypes);

    }

    static private NfaFunction[] nfaFunctions;

    // This data holder class is never instantiated
    private SNBTNfaData() {
    }

    /**
     * @return the table of function pointers that implement the lexical state
     */
    static NfaFunction[] getFunctionTableMap() {
        // We only have one lexical state in this case, so we return that!
        return nfaFunctions;
    }

    // Initialize the various NFA method tables
    static {
        SNBT.NFA_FUNCTIONS_init();
    }

    /**
     * Holder class for NFA code related to SNBT lexical state
     */
    private static class SNBT {

        static private TokenType NFA_SNBT_0(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.set(12);
            } else if (ch == '\'') {
                nextStates.set(1);
            } else if (ch == '-') {
                nextStates.set(21);
                nextStates.set(28);
                nextStates.set(19);
                nextStates.set(38);
                nextStates.set(31);
                nextStates.set(16);
            } else if (ch == '0') {
                nextStates.set(33);
                nextStates.set(11);
                nextStates.set(26);
                nextStates.set(17);
                nextStates.set(32);
            } else if (ch >= '1' && ch <= '9') {
                nextStates.set(37);
                nextStates.set(23);
                nextStates.set(3);
                nextStates.set(34);
                nextStates.set(10);
            } else if (ch == 'f') {
                nextStates.set(20);
            } else if (ch == 't') {
                nextStates.set(6);
            } else if (ch == 'I') {
                if (validTypes.contains(I))
                    return I;
            } else if (ch == ';') {
                if (validTypes.contains(_TOKEN_17))
                    return _TOKEN_17;
            } else if (ch == 'B') {
                if (validTypes.contains(B))
                    return B;
            }

            if (ch == '0') {
                if (validTypes.contains(INTEGER))
                    return INTEGER;
            } else if (ch >= '1' && ch <= '9') {
                nextStates.set(5);
                if (validTypes.contains(INTEGER))
                    return INTEGER;
            } else if (ch == '}') {
                if (validTypes.contains(CLOSE_BRACE))
                    return CLOSE_BRACE;
            } else if (ch == '{') {
                if (validTypes.contains(OPEN_BRACE))
                    return OPEN_BRACE;
            } else if (ch == ']') {
                if (validTypes.contains(CLOSE_BRACKET))
                    return CLOSE_BRACKET;
            } else if (ch == '[') {
                if (validTypes.contains(OPEN_BRACKET))
                    return OPEN_BRACKET;
            } else if ((ch == ',' || ch == ':') && validTypes.contains(COMMA)) {
                return COMMA;
            } else if ((ch == '\t' || ch == '\n' || ch == '\r' || ch == ' ')) {
                nextStates.set(9);
                if (validTypes.contains(WHITESPACE))
                    return WHITESPACE;
            }
            return null;
        }

        static private TokenType NFA_SNBT_1(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if ((ch >= 0x0 && ch <= '&') || (ch >= '(')) {
                nextStates.set(1);
            }
            if (ch == '\\') {
                nextStates.set(36);
            } else if (ch == '\'' && validTypes.contains(STRING)) {
                return STRING;
            }
            return null;
        }

        static private TokenType NFA_SNBT_2(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch >= '1' && ch <= '9') {
                nextStates.set(39);
            }
            return null;
        }

        static private TokenType NFA_SNBT_3(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9') {
                nextStates.set(3);
            } else if ((ch == 'L' || ch == 'l') && validTypes.contains(LONG)) {
                return LONG;
            }
            return null;
        }

        static private TokenType NFA_SNBT_4(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9') {
                nextStates.set(29);
            }
            return null;
        }

        static private TokenType NFA_SNBT_5(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9') {
                nextStates.set(5);
                if (validTypes.contains(INTEGER))
                    return INTEGER;
            }
            return null;
        }

        static private TokenType NFA_SNBT_6(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == 'r') {
                nextStates.set(14);
            }
            return null;
        }

        static private TokenType NFA_SNBT_7(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if ((ch == '+') || (ch == '-')) {
                nextStates.set(18);
            } else if (ch >= '1' && ch <= '9') {
                nextStates.set(24);
            }
            return null;
        }

        static private TokenType NFA_SNBT_8(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9') {
                nextStates.set(27);
            }
            return null;
        }

        static private TokenType NFA_SNBT_9(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if ((ch == '\t' || ch == '\n' || ch == '\r' || ch == ' ')) {
                nextStates.set(9);
                if (validTypes.contains(WHITESPACE))
                    return WHITESPACE;
            }
            return null;
        }

        static private TokenType NFA_SNBT_10(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == '.') {
                nextStates.set(8);
            } else if (ch >= '0' && ch <= '9') {
                nextStates.set(10);
            } else if ((ch == 'E') || (ch == 'e')) {
                nextStates.set(7);
            } else if ((ch == 'D' || ch == 'd') && validTypes.contains(DOUBLE)) {
                return DOUBLE;
            }
            return null;
        }

        static private TokenType NFA_SNBT_11(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if ((ch == 'B' || ch == 'b') && validTypes.contains(BYTE)) {
                return BYTE;
            }
            return null;
        }

        static private TokenType NFA_SNBT_12(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if ((ch >= 0x0 && ch <= '!') || (ch >= '#')) {
                nextStates.set(12);
            }
            if (ch == '\\') {
                nextStates.set(13);
            } else if (ch == '"' && validTypes.contains(STRING)) {
                return STRING;
            }
            return null;
        }

        static private TokenType NFA_SNBT_13(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == '"') {
                nextStates.set(12);
            }
            return null;
        }

        static private TokenType NFA_SNBT_14(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == 'u') {
                nextStates.set(22);
            }
            return null;
        }

        static private TokenType NFA_SNBT_15(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == 's') {
                nextStates.set(35);
            }
            return null;
        }

        static private TokenType NFA_SNBT_16(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == '0') {
                nextStates.set(11);
            } else if (ch >= '1' && ch <= '9') {
                nextStates.set(37);
            }
            return null;
        }

        static private TokenType NFA_SNBT_17(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if ((ch == 'S' || ch == 's') && validTypes.contains(SHORT)) {
                return SHORT;
            }
            return null;
        }

        static private TokenType NFA_SNBT_18(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch >= '1' && ch <= '9') {
                nextStates.set(24);
            }
            return null;
        }

        static private TokenType NFA_SNBT_19(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == '0' && validTypes.contains(INTEGER)) {
                return INTEGER;
            } else if (ch >= '1' && ch <= '9') {
                nextStates.set(5);
                if (validTypes.contains(INTEGER))
                    return INTEGER;
            }
            return null;
        }

        static private TokenType NFA_SNBT_20(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == 'a') {
                nextStates.set(25);
            }
            return null;
        }

        static private TokenType NFA_SNBT_21(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == '0') {
                nextStates.set(33);
            } else if (ch >= '1' && ch <= '9') {
                nextStates.set(3);
            }
            return null;
        }

        static private TokenType NFA_SNBT_22(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == 'e' && validTypes.contains(BOOLEAN)) {
                return BOOLEAN;
            }
            return null;
        }

        static private TokenType NFA_SNBT_23(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9') {
                nextStates.set(23);
            } else if ((ch == 'S' || ch == 's') && validTypes.contains(SHORT)) {
                return SHORT;
            }
            return null;
        }

        static private TokenType NFA_SNBT_24(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch >= '1' && ch <= '9') {
                nextStates.set(24);
            } else if ((ch == 'D' || ch == 'd') && validTypes.contains(DOUBLE)) {
                return DOUBLE;
            }
            return null;
        }

        static private TokenType NFA_SNBT_25(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == 'l') {
                nextStates.set(15);
            }
            return null;
        }

        static private TokenType NFA_SNBT_26(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == '.') {
                nextStates.set(4);
            } else if ((ch == 'E') || (ch == 'e')) {
                nextStates.set(30);
            } else if ((ch == 'F' || ch == 'f') && validTypes.contains(FLOAT)) {
                return FLOAT;
            }
            return null;
        }

        static private TokenType NFA_SNBT_27(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9') {
                nextStates.set(27);
            } else if ((ch == 'E') || (ch == 'e')) {
                nextStates.set(7);
            } else if ((ch == 'D' || ch == 'd') && validTypes.contains(DOUBLE)) {
                return DOUBLE;
            }
            return null;
        }

        static private TokenType NFA_SNBT_28(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == '0') {
                nextStates.set(17);
            } else if (ch >= '1' && ch <= '9') {
                nextStates.set(23);
            }
            return null;
        }

        static private TokenType NFA_SNBT_29(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9') {
                nextStates.set(29);
            } else if ((ch == 'E') || (ch == 'e')) {
                nextStates.set(30);
            } else if ((ch == 'F' || ch == 'f') && validTypes.contains(FLOAT)) {
                return FLOAT;
            }
            return null;
        }

        static private TokenType NFA_SNBT_30(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if ((ch == '+') || (ch == '-')) {
                nextStates.set(2);
            } else if (ch >= '1' && ch <= '9') {
                nextStates.set(39);
            }
            return null;
        }

        static private TokenType NFA_SNBT_31(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == '0') {
                nextStates.set(32);
            } else if (ch >= '1' && ch <= '9') {
                nextStates.set(10);
            }
            return null;
        }

        static private TokenType NFA_SNBT_32(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == '.') {
                nextStates.set(8);
            } else if ((ch == 'E') || (ch == 'e')) {
                nextStates.set(7);
            } else if ((ch == 'D' || ch == 'd') && validTypes.contains(DOUBLE)) {
                return DOUBLE;
            }
            return null;
        }

        static private TokenType NFA_SNBT_33(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if ((ch == 'L' || ch == 'l') && validTypes.contains(LONG)) {
                return LONG;
            }
            return null;
        }

        static private TokenType NFA_SNBT_34(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == '.') {
                nextStates.set(4);
            } else if (ch >= '0' && ch <= '9') {
                nextStates.set(34);
            } else if ((ch == 'E') || (ch == 'e')) {
                nextStates.set(30);
            } else if ((ch == 'F' || ch == 'f') && validTypes.contains(FLOAT)) {
                return FLOAT;
            }
            return null;
        }

        static private TokenType NFA_SNBT_35(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == 'e' && validTypes.contains(BOOLEAN)) {
                return BOOLEAN;
            }
            return null;
        }

        static private TokenType NFA_SNBT_36(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == '\'') {
                nextStates.set(1);
            }
            return null;
        }

        static private TokenType NFA_SNBT_37(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch >= '0' && ch <= '9') {
                nextStates.set(37);
            } else if ((ch == 'B' || ch == 'b') && validTypes.contains(BYTE)) {
                return BYTE;
            }
            return null;
        }

        static private TokenType NFA_SNBT_38(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch == '0') {
                nextStates.set(26);
            } else if (ch >= '1' && ch <= '9') {
                nextStates.set(34);
            }
            return null;
        }

        static private TokenType NFA_SNBT_39(int ch, BitSet nextStates, EnumSet<TokenType> validTypes) {
            if (ch >= '1' && ch <= '9') {
                nextStates.set(39);
            } else if ((ch == 'F' || ch == 'f') && validTypes.contains(FLOAT)) {
                return FLOAT;
            }
            return null;
        }

        static private void NFA_FUNCTIONS_init() {
            nfaFunctions = new NfaFunction[]{SNBT::NFA_SNBT_0, SNBT::NFA_SNBT_1, SNBT::NFA_SNBT_2, SNBT::NFA_SNBT_3, SNBT::NFA_SNBT_4, SNBT::NFA_SNBT_5, SNBT::NFA_SNBT_6, SNBT::NFA_SNBT_7, SNBT::NFA_SNBT_8, SNBT::NFA_SNBT_9, SNBT::NFA_SNBT_10, SNBT::NFA_SNBT_11, SNBT::NFA_SNBT_12, SNBT::NFA_SNBT_13, SNBT::NFA_SNBT_14, SNBT::NFA_SNBT_15, SNBT::NFA_SNBT_16, SNBT::NFA_SNBT_17, SNBT::NFA_SNBT_18, SNBT::NFA_SNBT_19, SNBT::NFA_SNBT_20, SNBT::NFA_SNBT_21, SNBT::NFA_SNBT_22, SNBT::NFA_SNBT_23, SNBT::NFA_SNBT_24, SNBT::NFA_SNBT_25, SNBT::NFA_SNBT_26, SNBT::NFA_SNBT_27, SNBT::NFA_SNBT_28, SNBT::NFA_SNBT_29, SNBT::NFA_SNBT_30, SNBT::NFA_SNBT_31, SNBT::NFA_SNBT_32, SNBT::NFA_SNBT_33, SNBT::NFA_SNBT_34, SNBT::NFA_SNBT_35, SNBT::NFA_SNBT_36, SNBT::NFA_SNBT_37, SNBT::NFA_SNBT_38, SNBT::NFA_SNBT_39};
        }

    }

}


